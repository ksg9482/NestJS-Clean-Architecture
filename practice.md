## 유즈 케이스
* 모은 책의 목록 가져오기
* 단일 도서 세부 정보 가져오기
* 새 책 추가
* 새 저자 추가

###  새 책 추가 유즈 케이스
새 책 추가 유즈 케이스의 주요 책임은 다음과 같다.

* 비즈니스 규칙 검증
* 해당 도서 DB 돈재 확인
* 새 책 객체 생성
* 새 책 DB 저장
* 도서관 CRM 시스템 업데이트

유즈 케이스의 책임을 보면 유즈 케이스에 두가지 종속성이 있다.

* 데이터베이스 서비스 - 책 세부 정보를 유지하고 시스템에 존재하는지 확인. 이 기능은 SQL 또는 MongoDB를 호출하는 클래스로 구현 할 수 있다.
* CRM 서비스 - 도서관 CRM 어플리케이션에 새 책에 대해 알려야 한다. 이 기능은 외부 시스템(모든 시스템일 수 있음)을 호출하는 서비스로 구현 될 수 있다.

### 유즈케이스가 구체적인 DB를 모른다고 가정해야 한다
유즈케이스는 엔티티와 비즈니즈 로직에 대해서만 알고 있어야 한다. 그렇지 않으면 유즈케이스를 테스트하는 데 어려워 질 수 있다.

유즈케이스는 구체적인 DB를 모르지만, DB에 책을 보관하는 등 상호작용 해야한다. 이에 대한 해결방법은 유즈케이스와 외부 세계 사이에 게이트웨이를 구축하는 것이다.

이 방법은 특정 DB 또는 특정 시스템에 대한 종속성을 만드는 대신 추상화에 대한 종속성을 만든다. 

추상화는 서비스를 구현하는 것이 아니라 청사진을 만드는 것이다. 서비스에서 필요한 기능만 정의한다.

Abstractions를 사용하여 유즈 케이스와 프레임워크 간의 계약을 정의한다. 계약이란 기본적으로 원하는 서비스의 기능 서명이다. 

예를 들어 CRM서비스는 책 객체를 매개변수로 가져오고 부울(Boolean) 값이 있는 약속을 반환하는 notify함수를 제공해야 한다.

### 유즈케이스 종속성
추상화를 정의하려면 다음이 필요하다
* 데이터 서비스 추상화
* CRM 서비스 추상화

데이터 서비스 추상화는 3개의 리포지토리를 노출한다.
* 도서 리포지토리
* 작성자 리포지토리
* 장르 리포지토리

이러한 각 저장소는 find, findById, Insert, Update, Delete 등과 같은 CRUD 기능을 제공해야 한다.

### 주요 추상화
src/core/abstracts 의 샘플 앱에서 모든 추상화를 찾을 수 있다.

* 일반 리포지토리 - 각 엔티티 리포지토리는 기본 CRUD 작업을 지원해야 한다. 모든 엔티티 리포지토리에 대한 추상 클래스 역할을 할 일반 리포지토리 외에도 각 리포지토리에 대해 다른 기능이 필요한 경우 별도로 정의 할 수 있다.

* 데이터 서비스 - 모든 엔티티 저장소를 노출한다. 

유즈케이스는 추상화에만 의존하고, 서비스의 실제 구현을 모른 채 서비스를 사용한다.
외부 서비스 구현에 대한 변경 사항은 비즈니스 로직에 영향을 미치지 않는다. 

### 컨트롤러와 프레젠터
이 계층의 소프트웨어 유즈케이스 및 엔티티에 가장 편리한 형식에서 데이터베이스 또는 웹과 같은 일부 외부 기관에 가장 편리한 형식으로 데이터를 변환한다. 예를 들어 이 계층은 GUI의 MVC 아키텍처를 완전히 포함한다. 프레젠터, 뷰, 컨트롤러는 모두 여기에 속한다.

컨트롤러, 프레젠터 및 게이트웨이는 중간 계층이다. 유즈케이스를 외부 세계에 보내고 반대 방향으로도 돌리는 어뎁터이다.

컨트롤러의 역할은 사용자 입력에 응답하고, 유효성을 검사하고, 일부 비즈니스 논리를 수행하고, 일반적으로 어플리케이션의 상태를 변경한다.

반면에 프레젠터는 일종의 리포지토리에서 데이터를 수신하고 뷰/API 계층에 대한 데이터 형식을 지정한다.

* 컨트롤러
 * 유저 입력을 받는다(DTO)
 * 유저 입력 삭제를 확인한다
 * 유저 입력을 유즈케이스에서 예상하는 모델로 변환한다. 예를 들어 날짜 형식을 변경하는 등.
 * 유즈케이스를 호출하여 새 모델을 전달한다.

컨트롤러는 어뎁터이며 여기에는 비즈니스 로직이 필요하지 않고 데이터 형식 지정 로직만이 필요하다.

* 프레젠터
 * 문자열과 날짜의 형식을 지정한다
 * 플래그 같은 프레젠테이션 데이터를 추가한다
 * UI에 표시할 데이터를 준비한다.

프레젠터는 어플리케이션 리토지토리에서 데이터를 가져온 다음 클라이언트에 대한 형식화된 응답을 작성한다.

노드 구현에서는 MVC 프로젝트와 마찬가지로 컨트롤러와 프레젠터를 함께 구현한다. 컨트롤러를 구현하기 위해 NestJS 기능을 사용하고, 유효성 검사 파이프를 사용하여 입력의 유효성을 검사하고 변환파이프를 사용하여 DTO를 비즈니스 객체로 변환 한다.

NestsJS는 내부적으로 class-validator 를 사용하므로 class-validator 데코레이터 를 사용하여 DTO 객체의 유효성을 검사할 수 있고, 사용자 지정 유효성 검사를 추가할 수도 있다.

## 바깥 레이어
이 레이어는 모든 세부사항이 들어가는 곳이다. 웹, 데이터베이스는 세부사항이다. 이러한 것들이 해를 끼치지 못하도록 외부에 보관한다.

프레임워크 계층은 데이터베이스, 모니터링, 처우, 오류처리 등과 같은 구현들이 포함된다.

샘플 프로젝트에서 프레임워크는 다음과 같이 구현된다.

* 웹 어플리케이션 프레임워크는 NestJS에 의해 구현된다.
* 데이터베이스 서비스는 mongoose를 사용하여 구현된다.
* CRM은 단순한 모의 서비스이다.

## 의존성 주입
NestJS는 DataServices를 요청할 때마다 MongoDataServices인스턴스를 주입한다.

예를 들어 mongo를 sql로 교체하려면 다음 작업만 하면 된다.

* sql을 사용하는 새 데이터베이스 클래스 및 리포지토리를 만들고 데이터 서비스 추상을 따른다.
* 모듈 파일에서 NestJS에 새로운 SQL 데이터 서비스를 사용하도록 지시한다.

## 요약
프레임워크에서 핵심 비즈니스 로직을 분리하는 계층별 서비스를 구축하면 느슨하게 결합된 레이어 아키텍처를 구현할 수 있다.

[Clean Node.js Architecture —With NestJs and TypeScript](https://betterprogramming.pub/clean-node-js-architecture-with-nestjs-and-typescript-34b9398d790f)